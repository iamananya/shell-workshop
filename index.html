b<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/serif.css" id="theme" />

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/monokai.css"
      id="highlight-theme"
    />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section style="font-size: 30px">
          <h2>Workshop On</h>
          <h2>Linux Environment <br />Shell Scripting <br />Vim</h2>
          <br />
          <br />
          <h3>Presented by:KOSS</h3>
        </section>
        <section>
          <h1>Linux</h1>
          <blockquote>
	    Linux is a Kernel
	    <br>
	    kernel is a software written just above the hardware.
	    
	    <br>
	    <img src="https://raw.githubusercontent.com/iamananya/shell-workshop/master/images/hardware.png"  height="300" width="500">

          </blockquote>
        </section>
        <section>
          <h3>Why Linux???</h3>
          <ul style="font-size: 30px">
            <li>Code is open sourced</li>
            <li>Security - Most common malicious programs target windows.Linux is inherently more secure than windows</li>
            <li>
              Popular Linux distros are <em>Fedora</em>, <em>Ubuntu</em>, <em
                >Kali Linux</em
              >
            </li>
			<li>Easy to install programming tools and software not matter what field you are</li>
			<li>Updates are peaceful.</li>

		</ul>
		<img src="https://raw.githubusercontent.com/iamananya/shell-workshop/master/images/update.png" width="500px" height="300px">
	 </section>
	 <section>
		 <h2>GUI Versus CLI</h2>
		 <div style="font-size: 30px;">
			 <ul>
				
					
						 <li>
							GUI:Graphical User Interface
							<br>
							Uses graphics,just like Icons ,to interact with the operating system
							<br>
							A GUI needs to use additional system resources to load the graphical part thus it is going to be slower than using the command line
							
						 </li>
						 
							
						
						
						 <li>
							CLI:Command Line Interface
							 <br>
							 Uses textual commands to interact with the operating system 
							 <br>
						 CLI provides greater flexibility of use.It can be used to easily do things that are difficult or even impossible to do with a GUI.
						 </li>
						 
							
						 
					
					 
					 
					 
				 
			 </ul>
		 </div>
	 </section>
        <section style="font-size: 30px">
          <h2>What is a Shell?</h2>
          <ul>
            <li>Shell is a program that lets you run shell commands.​</li>
            <li>
              A Shell is a command line interpreter, which runs your shell
              scripts.​
            </li>
          
            <li>
              Examples:​ tcsh​ ,
              fish ,​ <strong>Bourne Again Shell (bash)</strong>,​ zsh etc.​
            </li>
            <blockquote>
              Type <strong>$cat /etc/shells</strong> to display the shells
              available in your system
            </blockquote>
          </ul>
        </section>
        <section style="font-size: 30px">
          <h2>Linux Directory</h2>
          <blockquote>
            <ul>
              <li>/bin :Binary files</li>
              <li>/boot : Boot loader files</li>
              <li>/dev :device files</li>
              <li>/lib : system libraries</li>
              <li>/tmp : Temporary Files</li>
              <li>/home :home directories .... and a lot more</li>
            </ul>
          </blockquote>
        </section>
        <section>

          <h2>Basic linux Commands</h2>
	 </section>
	 <section>
		 <h3>pwd</h3>
		 <div style="font-size: 30px;">
			<ul>
				<li>
					pwd stands for Print Working Directory.
				</li>
				<li>
					It prints the path of the working directory, starting from the root.
				</li>
			</ul>

		 </div>
	 </section>

        <section>
          <h3 style="text-transform: lowercase">ls</h3>
          <div style="font-size: 30px">
            <ul>
              <li>This is used to list files.​</li>
              <li>
                Usage: ls -[Options] [path]<em>
                  {Note:If a path is not given, current directory is
                  assumed.}</em
                >​
              </li>
              <li>
                Path can also contain wildcards. Example: ls *.pdf​ will list
                all the pdf files in that directory
              </li>
              <li>
                Options consist of one or a combination of character flags that
                invoke special functions:​
              </li>
              <ul>
                <li>l : List files with additional metadata​</li>
                <li>a : Show hidden files also. (Name begins with .</li>
                <li>h : Show file sizes in MBs and GBs instead of bytes.​</li>
                <li>t : Sort by date modified.​</li>
				<li>r: option flag lists files/directories in reverse order.</li>
                <li>Multiple options can be combined as: ls -lah .​</li>
              </ul>
            </ul>
          </div>
        </section>
        <section>
          <blockquote>
            Excercise: Open a terminal and create 2 hidden files and 2 visible files.Then the list of all files
            (both hidden and visible) .Show files sorted by the date modified and with reverse date modified.​
          </blockquote>
        </section>
		<section>
			<h3>cat,head ,tail</h3>
		   <img src="https://raw.githubusercontent.com/iamananya/shell-workshop/master/images/cat.png"  height="150" width="250">
		   <ul style="font-size: 30px;">
			   <li>cat stands for conCATenate .</li>	
			   <li>cat file1 file2 file3 will output all​ the 3 files combined in the given sequence.​</li>
			   <li>However, in practice, people use	cat	to print out the 1 full file only.​</li>
			   <li>head:prints out the first few lines of a file and	tail:prints out the last few  lines of a file.​</li>
			   <li>Both accept a parameter  number n, This limits the output to​ n number of lines</li>
			   <li>Example: to get the first 15 lines of a line, 
				   <em>run:​head -n15 file</em></li>
		   </ul>
		</section>
        <section>
          <h2 style="text-transform: lowercase">Echo and printf</h2>
          <div style="font-size: 30px">
            <ul>
              <li>It is  used to print stuff ​</li>
              <li>printf supports formatted output.​</li>
              <li>UnLike C,​ echo is more common in use than​ printf</li>
              <li>
                Usage: echo "some text" or ​printf "format string" "parameters"​
              </li>
              <br />
            </ul>
			<blockquote style="text-align: left;">
				
				Operators for redirecting output from specific files / streams are:
				<br>
				 > outputfile Redirects the output to a new file (Existing file is overwritten).
				 <br>
				 >> outputfile Appends the output to a file.
			</blockquote>
          </div>
        </section>
		

					
        
	 
	 <section>
		 <h3>find</h3>
		 <div style="font-size: 30;">
			<ul>
				<li>
					find is quite powerful as a utility
				</li>
				<li>
					Its basic task is to recursively print out all the files and directories from a given
path.
				</li>
				<blockquote>
					$ find . # Search starts from current directory
					<br>
					$ find / # Search starts from root
				</blockquote>
				<li>
					Although there are many filters and actions that find can perform
				</li>
				<li>
					For example, find -type f finds only files. Change f to d and it will find only directories.
				</li>
			</ul>
		
		</div>
	 </section>
	 <section>
		 <div style="font-size: 30px; text-align: left;">
			 <li>
				find -name expr will match expr to the file names. expr can be a
				string with wildcards 
			 </li>
			 <li>
				These filters can also be combined
			 </li>
			 <li>
				The default action is -print . 
			 </li>
			 <li>
				However find -delete will delete all the files it was supposed to print.
			 </li>
			 <li>
				 Furthermore, find -exec will execute arbitrary command on the file names. 
			 </li>
			<blockquote>
				For example:
				<br>
				find -name "*.txt" 
				<br>
				find the text files
			</blockquote>
			<li>
				Know more by running man find
			</li>
		 </ul>
		</div>
		<ul>
	 </section>
	 <section>
		 <h2>grep</h2>
		 <div style="font-size: 30px;">
			 <ul>
				 <li>grep	prints those lines in a given list of files that match a pattern.​</li>
				 <li>Usage:	grep pattern filename .​</li>
				 <li>Another common usage is to show the output of some other command to grep. For  example:<blockquote>​grep "name" in name.txt </blockquote>​</li>
				 <li>This will find all lines in a file that have the string “name” in it.​
					 <br>Use -i for case insensitive output
				 </li>
				 
				 <!-- <li>pattern	can be a Regular Expression too. For example:​<blockquote>whois google.com grep -i	[Cc]ountry</blockquote> </li> -->
				 <!-- <li>will fetch the whois record of Google.com using whois CLI (installed separately) and  from that record, will find out all string which have either “country” or “Country” in it.​</li> -->
			 </ul>
		 </div>
	 </section>
	 <section>
		<h3 style="text-transform: lowercase">which</h3>
		<div style="font-size: 30px">
		  <ul>
		    <li>Most command that you run in the shell actually is an executable located  somewhere in your PATH (it is an environment variable, more on that later).​</li>
		    <li>To find out which particular executable is being run,	which	is</li>
		    <blockquote style="text-align: center;">$ which echo​ 
			<br>
			/usr/bin/echo</blockquote>
			
		  </ul>
		</div>
	     </section>
	     <section>
		<h3>cp, mv and mkdir​</h3>
		<div style="font-size: 30px;">
		<ul>
			<blockquote>cp some/path/file some/other/path</blockquote> <li> copies file from <em>some/path</em> to
				<em>some/other/path </em>.</li>
			<li>To recursively copy a folder and all its files and subdirectories, we use<em>	cp -r </em>.​</li>
			<li>The main job of<em>mv</em>is to move files and folders from one directory to the other</li>
			<li>Althought	<em>mv file newname</em>	renames the file <em>file</em>	to	<em>newname </em></li>
			<li>Paths in cp and mv also support wildcards. For example,​

				<em>cp yt-slides/*.pdf folder2/</em>	copies only the pdf files.​
				<li>
				
				<em>mkdir</em>	makes directories. <em>mkdir existing/path/new_directory_to_make </em>. This creates a new
				directory <em>new_directory_to_make</em> under the existing path <em>existing/path</em> .​</li>
			</li>
				<li>However, if the parent directory doesn’t exist yet, we can create the whole hierarchy​</li>
		</ul>
	</div>
	     </section>
	     <section>
		     <h3>rm and rmdir​</h3>
		     <div>
			     <ul>
				     <li>
					rmdir	removes empty directories.​   
				     </li>
				     <li>rm	is a general command for removal of files and folders.​</li>
				     <li>To recursively delete, use the	-r	flag with	rm .​</li>
					 <li>
						To forcefully delete, use the	-f	flag with	rm .
					 </li>

			     </ul>
			     <blockquote>
				Use rm -rf <strong>Responsibly​ </strong>as it can delete any file and maybe your system 
			     </blockquote>
		     </div>

	     </section>
	     <section>
		     <h3>wc, sort</h3>
		     <div style="font-size: 30px;">
			<ul>
				These fall under the category of text manipulation programs.
				<li>wc returns the newline, word and byte count for each of the files that are passed
					to it.</li>
					<li>We can get the individual newline, word or byte count by using -l , -w or
						-c flags respectively.</li>
						<li>
							sort sorts the lines of a document in lexicographical order. Although the
ordering can be changed using appropriate flags.
						</li>
						<li>
							sort -u gives the unique lines in the document	
						</li>
						<li>To sort files numerically use -n</li>
						
						
			</ul>

		     </div>
	     </section>
		 
	     <section>
		     <h3>wget and curl</h3>
		     <div style="font-size: 30px;">
			     <ul>
				     <li>These programs are used to fetch resources from the internet.</li>
				     <li>wget , as the name suggests, performs only GET requests.</li>
				     <li>
					By default, wget saves the output to a file in the current directory. However, this
					can be changed using the -o flag. 
				     </li>
				     <li>
					cURL is a more generic tool. It can be used to perform arbitrary HTTP requests.   
				     </li>

			     </ul>
			     <blockquote>
				For example, sending a POST request to an URL through curl is as follows:
				curl -X POST -H 'Content-type: application/json'
				-d '{"message": "Hello"}' http://url/endpoint
				-X defines request method, -H defines headers, -b defines Request body.  
			     </blockquote>
		     </div>
	     </section>
		 <section>
			<h3>Pipe (|)</h3>
			<div style="font-size: 30px;">
				<ul>
					<li>
						This direct connection between commands/ programs/ processes allows them to operate simultaneously and permits data to be transferred between them continuously
					</li>
					<li>
						command_1 | command_2 | command_3 | .... | command_N 
					</li>
					
				</ul>
			</div>
		   
		</section>
	     <section>
		<blockquote>
			<h3> Handy Commands</h3>
			<p>Look for the usage of these commands:</p>
			<ul>
				man : for manual 
				<br>
				example:man echo,man ls
				<br>
			 history : for viewing your terminal history

				<br>
				time : to check the compilation  time	
			</ul>
		</blockquote>
	     </section>
	     <section><h3>Variables and Control FLow</h3></section>
	     <section>
		     <h3>variables</h3>
		     <div style="font-size: 30px;">
			<ul>
				<li>
					Variables here are not typed.
				</li>
				<li>
					All variables, when USED should be preceeded by $ symbol.

				</li>
				<li>
					However, while declaring you should never use the $ symbol
				</li>
			</ul>
			<blockquote>
				Example:
				<br>
$ a=2 # Don't forget to put no space around equals
<br>
$ echo $a # Btw this is a comment.
			</blockquote>
		     </div>
	     </section>
	     <section>
		     <h3>Environment Variables</h3>
		     <div style="font-size: 30px;">
			     <ul>
					 <li>Variables that you want save in your system so that you can access from anywhere</li>
					 <li>For temporary usage use <em>export variable_name=value</variable_name></em></li>
					 <li>For permanent usage save it in your ~/.bashrc file</li>
				</ul>
				</div>
	     </section>
		 <section>
			<blockquote style="font-size: 30px; text-align: left">
			  <h2>Single and double quotes in bash</h2>
  
			  In bash, both single and double quotes are allowed. However there is a
			  subtle difference​ in behaviour. Inside double quoted string, you
			  can use sub-commands enclosed by​ $() . This is not possible with
			  single quotes.
			  <br />
			  <strong
				>Exercise: Run​ echo"$( ls /bin)"​ and​ echo '$(ls /bin)' to see
				the difference</strong
			  >
			</blockquote>
	   </section>
	     <!-- <section>
		     <h3>Some Special Variables</h3>
		     <div style="font-size: 30px;">
			<ul>
				<li>
					$$ is the PID of the script.
				</li>
				<li>
					$! is the PID of most recently executed background pipeline.
				</li>
				<li>
					In a bash script, $0 can be used to get the script name. $i for i >= 1 can be
					used to get the argument variables. (Compare with sys.argv of Python)
				</li>
				<li>
					$PS1 controls the line shown at each promp
				</li>
				<li>
					$PATH contains a : separated list of
				</li>
			</ul>
		     </div>
	     </section> -->
		 <section>
			<h3>.sh scripts</h3>
			<div style="font-size: 30px;">
			<ul>
				<li>Apart from running from terminal, we can also put our commands in a script file.​</li>
				<li>Files can be run as	sh script.sh .​</li>
				<li>To be able to run the script as an executable, we need to set executable flag on it.  This is done by:​
					<em> chmod +x script.sh​</em>
				</li>
				<li>But before that, we need to declare which shell to use to run it.​</li>
				<li>This is done on the very first line of the script, by writing:​</li>
		   
			</ul>
			<blockquote>
			  <strong>#!/bin/bash</strong>  
			  This is called the	Shebang	line.​
			  <br>
			  Following the previous 2 steps, one can then execute the script as:​
			  <strong>$./script</strong>
			</blockquote>
	   </div>
		</section>
	     <section>
		     <h3>Conditionals</h3>
		     <div style="font-size: 30px;">
			<p>Bash doesn’t use braces or indentation to mark the blocks.</p>
			<blockquote style="text-align: left;">
				The basic structure of an if block is as follows:
				<br>
				if [condition1]
				<br>
				then
<br>
# Block to execute
<br>
elif [condition2]
<br>
then
<br>
# Block
<br>
else
<br>
# Block
<br>
fi
			</blockquote>
			<ul><li>
				[] are a reference to the test command, which is run internally to check for
the conditions.
			</li></ul>
		     </div>

	     </section>
	     <section>
		<div style="font-size: 30px;">
			<ul>
				<li>
					Normal operators like = , != apply to String comparison.
				</li>
				<li>
					Integer comparisons are done using -eq , -gt and -lt . (Guess their
					meaning!).	
				</li>
				<li>
					! Expr negates the expression Expr .
				</li>
				<li>
					Some special comparisons:
					<ul>
						<li>
							-n str : Length of string is > 0.
						</li>
						<li>
							-z str : Length is == 0.
						</li>
						<li>
							-d file : file is an existing directory.
						</li>
						<li>
							-e file : file exists
						</li>
						<li>
							
							 -r file : file exists and the read permission is granted.
						</li>
						<li>
							 -s file : file exists and is not empty
						</li>
						<li>
							-w file : file exists and the write permission is granted
						</li>
						<li>
							-x file : file exists and the execute permission is granted.
						</li>
					</ul>
				</li>
			</ul>
		</div>
	     </section>
	     <section>
		     <h3>
			     For Loops
		     </h3>
		     <div style="font-size: 30px;">
			<ul>
				<li>
					Bash’s for loop is similar to the Python one.	
				</li>
				<li>
					Although the concept of array is not present in bash.	
				</li>
				
			</ul>
			<blockquote>
				Common patterns:
for i in var1 var2 var3
do
# Do something with $i
# vari can be numbers also
done
			</blockquote>

		     </div>
	     </section>
	     <section>
		    <blockquote>
			for i in $(Command with multiple line output)
			do
			# $i will contain one line at a time
			done  
		    </blockquote>

		    <br>
		    <br>
		    <blockquote>
			for i in {1..5} # {START..STOP} range
			for i in {1..5..2} # {START..STOP..STEP} range
			for i in $(seq 1 100) # 1 to 100 sequence   
		    </blockquote>
	     </section>
	     <section>
		     <h3>While loop</h3>
		     <div style="font-size: 30px;">
			<ul>
				<li>
					while loops iterate while their conditions are true.
				</li>
				<blockquote>
					Syntax:
while [condition]
do
# Something to do
done
				</blockquote>
				<li>
					A common pattern observed while using the while loop is incrementing the
variables. This is done as shown: x=$(( $x + 1 )) .
				</li>
				<li>
					Another common usage of while is with the read command:	
				</li>
			</ul>

		     </div>
	     </section>
	     <section>
		     <div style="font-size: 30px;">
			<blockquote>
				while read p
				do
				# Something with $p
				done	
			</blockquote>
			<ul>
				This reads from stdin line by line until EOF is received.
				<li>
					while with no condition is an infinite loop.
				</li>
				<li>
					break and continue work as common sense predicts
				</li>
				<li>
					Exercise: Read about case statement
				</li>
			</ul>

		     </div>
	     </section>
	    
	   
	     <section>
		   <h2>Hands On Excerise</h2>  
	     </section>
	     <section>
		     <h3>Problem </h3>
		     <blockquote>
			     
			    create 2 directories - c_codes and py_codes
				<br>
				using loops create 6 files
				 1.c, 3.c, 5.c
				 <br>
				 2.py, 4.py, 6.py <br>
				 put odd numbered files  in c_codes directory
				 put even numbered files in py_codes directory
		     </blockquote>
	     </section>
	     
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
